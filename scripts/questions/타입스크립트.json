{
  "metadata": {
    "id": "wp202408-TS-001-O",
    "title": "타입스크립트 기본 개념 문제세트(객관식)",
    "description": "타입스크립트 입문자를 위한 기본 문법과 개념 점검용 객관식 문제 10문항",
    "subject": "타입스크립트(객관식)",
    "category": [
      "TypeScript",
      "프로그래밍언어"
    ],
    "difficulty": "Beginner",
    "version": "v1.0",
    "created_at": "2025-08-04",
    "updated_at": "2025-08-04",
    "author": "ChatGPT + User",
    "source": "직접 제작",
    "tags": [
      "TypeScript",
      "JavaScript",
      "정적 타입"
    ],
    "license": "CC BY-NC-SA",
    "num_questions": 10
  },
  "questions": [
    {
      "id": 1,
      "type": "objective",
      "question": {
        "questionText": "타입스크립트의 주요 특징은 무엇인가?",
        "questionExplanation": []
      },
      "choices": [
        {
          "choice": "동적 타입 언어이다.",
          "choiceExplanation": "테스트용 설명입니다.1"
        },
        {
          "choice": "HTML 템플릿 언어이다.",
          "choiceExplanation": "테스트용 설명입니다.1"
        },
        {
          "choice": "런타임에서 타입을 검사한다.",
          "choiceExplanation": "테스트용 설명입니다.1"
        }
      ],
      "answer": {
        "answerText": "정적 타입을 지원하는 자바스크립트 상위 집합이다.",
        "answerExplanation": "TypeScript는 자바스크립트에 정적 타입을 추가한 상위 집합 언어이다."
      },
      "tags": [
        "기본 개념",
        "TypeScript"
      ]
    },
    {
      "id": 2,
      "type": "objective",
      "question": {
        "questionText": "다음 중 타입스크립트에서 변수에 타입을 명시하는 올바른 문법은?",
        "questionExplanation": []
      },
      "choices": [
        {
          "choice": "let name = String;",
          "choiceExplanation": ""
        },
        {
          "choice": "let name := string;",
          "choiceExplanation": ""
        },
        {
          "choice": "let name string = 'Kim';",
          "choiceExplanation": ""
        }
      ],
      "answer": {
        "answerText": "let name: string = 'Kim';",
        "answerExplanation": "`:` 기호를 사용해 변수의 타입을 지정할 수 있다. 예: `let name: string = 'Kim';`"
      },
      "tags": [
        "문법",
        "타입 표기"
      ]
    },
    {
      "id": 3,
      "type": "objective",
      "question": {
        "questionText": "`any` 타입의 특징은?",
        "questionExplanation": []
      },
      "choices": [
        {
          "choice": "타입 추론이 엄격하게 적용된다.",
          "choiceExplanation": ""
        },
        {
          "choice": "오직 숫자만 저장할 수 있다.",
          "choiceExplanation": ""
        },
        {
          "choice": "타입 검사가 강제로 적용된다.",
          "choiceExplanation": ""
        }
      ],
      "answer": {
        "answerText": "모든 타입을 허용하며 타입 검사를 생략한다.",
        "answerExplanation": "`any`는 어떤 타입도 허용하며 타입 안정성을 포기하는 대신 유연하게 사용 가능하다."
      },
      "tags": [
        "타입 시스템",
        "any"
      ]
    },
    {
      "id": 4,
      "type": "objective",
      "question": {
        "questionText": "다음 중 유니언 타입을 나타내는 문법은?",
        "questionExplanation": []
      },
      "choices": [
        {
          "choice": "number&string",
          "choiceExplanation": ""
        },
        {
          "choice": "(number,string)",
          "choiceExplanation": ""
        },
        {
          "choice": "number:string",
          "choiceExplanation": ""
        }
      ],
      "answer": {
        "answerText": "number | string",
        "answerExplanation": "`|` 기호를 사용해 두 개 이상의 타입을 허용하는 유니언 타입을 정의한다."
      },
      "tags": [
        "타입 문법",
        "유니언"
      ]
    },
    {
      "id": 5,
      "type": "objective",
      "question": {
        "questionText": "타입스크립트 인터페이스의 주요 목적은?",
        "questionExplanation": []
      },
      "choices": [
        {
          "choice": "HTML 마크업 정의",
          "choiceExplanation": ""
        },
        {
          "choice": "네트워크 통신 처리",
          "choiceExplanation": ""
        },
        {
          "choice": "객체의 타입 구조 정의",
          "choiceExplanation": ""
        }
      ],
      "answer": {
        "answerText": "객체의 타입 구조 정의",
        "answerExplanation": "인터페이스는 객체가 가져야 할 프로퍼티와 타입을 명확하게 정의한다."
      },
      "tags": [
        "객체 타입",
        "interface"
      ]
    },
    {
      "id": 6,
      "type": "objective",
      "question": {
        "questionText": "타입스크립트에서 타입을 커스터마이징하는 데 사용하는 키워드는?",
        "questionExplanation": []
      },
      "choices": [
        {
          "choice": "object",
          "choiceExplanation": ""
        },
        {
          "choice": "define",
          "choiceExplanation": ""
        },
        {
          "choice": "contract",
          "choiceExplanation": ""
        }
      ],
      "answer": {
        "answerText": "type",
        "answerExplanation": "`type` 키워드를 사용하면 새 타입 별칭을 만들어서 재사용할 수 있다."
      },
      "tags": [
        "타입 정의",
        "type alias"
      ]
    },
    {
      "id": 7,
      "type": "objective",
      "question": {
        "questionText": "타입스크립트에서 선택적 속성은 어떻게 표기하는가?",
        "questionExplanation": []
      },
      "choices": [
        {
          "choice": "속성 이름 뒤에 `&`",
          "choiceExplanation": ""
        },
        {
          "choice": "속성 이름 앞에 `!`",
          "choiceExplanation": ""
        },
        {
          "choice": "속성 이름 뒤에 `#`",
          "choiceExplanation": ""
        }
      ],
      "answer": {
        "answerText": "속성 이름 뒤에 `?`",
        "answerExplanation": "`?`를 붙이면 해당 속성이 있어도 되고 없어도 되는 선택적 속성이 된다."
      },
      "tags": [
        "interface",
        "선택적 속성"
      ]
    },
    {
      "id": 8,
      "type": "objective",
      "question": {
        "questionText": "타입 단언(type assertion)을 사용할 때 사용하는 문법은?",
        "questionExplanation": []
      },
      "choices": [
        {
          "choice": "as type?",
          "choiceExplanation": ""
        },
        {
          "choice": "(value as type)?",
          "choiceExplanation": ""
        },
        {
          "choice": "value -> type",
          "choiceExplanation": ""
        }
      ],
      "answer": {
        "answerText": "value as type",
        "answerExplanation": "값 뒤에 `as 타입`을 붙여 타입스크립트에게 개발자가 타입을 보장함을 알릴 수 있다."
      },
      "tags": [
        "타입 단언",
        "문법"
      ]
    },
    {
      "id": 9,
      "type": "objective",
      "question": {
        "questionText": "타입스크립트에서 제네릭을 사용하는 이유는?",
        "questionExplanation": []
      },
      "choices": [
        {
          "choice": "타입 에러를 무시하기 위해",
          "choiceExplanation": ""
        },
        {
          "choice": "모든 타입을 제거하기 위해",
          "choiceExplanation": ""
        },
        {
          "choice": "특정 타입에 고정시키기 위해",
          "choiceExplanation": ""
        }
      ],
      "answer": {
        "answerText": "재사용성과 타입 안전성을 동시에 확보하기 위해",
        "answerExplanation": "제네릭은 다양한 타입에 대해 유연하게 코드를 작성하면서도 타입 체크를 유지할 수 있게 해준다."
      },
      "tags": [
        "제네릭",
        "타입 안전성"
      ]
    },
    {
      "id": 10,
      "type": "objective",
      "question": {
        "questionText": "`readonly` 키워드를 사용하는 목적은?",
        "questionExplanation": []
      },
      "choices": [
        {
          "choice": "속성 값을 모두 필수로 만들기 위해",
          "choiceExplanation": ""
        },
        {
          "choice": "속성 값을 나중에 할당하기 위해",
          "choiceExplanation": ""
        },
        {
          "choice": "속성 값을 변경하지 못하게 하기 위해",
          "choiceExplanation": ""
        }
      ],
      "answer": {
        "answerText": "속성 값을 변경하지 못하게 하기 위해",
        "answerExplanation": "`readonly`는 한 번 초기화된 후 값을 변경할 수 없도록 만든다."
      },
      "tags": [
        "타입 안정성",
        "readonly"
      ]
    }
  ]
}